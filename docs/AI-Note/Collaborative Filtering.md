# Collaborative Filtering

## 1.介绍

​		协同过滤(Collaborative Filtering)作为推荐算法中最经典的类型，包括在线的协同和离线的过滤两部分。所谓在线协同，就是通过在线数据找到用户可能喜欢的物品，而离线过滤，则是过滤掉一些不值得推荐的数据，比比如推荐值评分低的数据，或者虽然推荐值高但是用户已经购买的数据。

　　协同过滤的模型一般为m个物品，m个用户的数据，只有部分用户和部分数据之间是有评分数据的，其它部分评分是空白，此时我们要用已有的部分稀疏数据来预测那些空白的物品和数据之间的评分关系，找到最高评分的物品推荐给用户。

一般来说，协同过滤推荐分为三种类型。

1. **基于用户(user-based)的协同过滤**
2. **基于项目(item-based)的协同过滤**，
3. **基于模型(model based)的协同过滤**。

​      基于用户(user-based)的协同过滤主要考虑的是用户和用户之间的相似度，只要找出相似用户喜欢的物品，并预测目标用户对对应物品的评分，就可以找到评分最高的若干个物品推荐给用户。而基于项目(item-based)的协同过滤和基于用户的协同过滤类似，只不过这时我们转向找到物品和物品之间的相似度，只有找到了目标用户对某些物品的评分，那么我们就可以对相似度高的类似物品进行预测，将评分最高的若干个相似物品推荐给用户。

​       基于模型(model based)的协同过滤是目前最主流的协同过滤类型了，我们的一大堆机器学习算法也可以在这里找到用武之地。

**如何理解用户偏好和用户相似度？（基于用户的推荐）**

​		举个例子，四川人喜欢吃辣的食物就是一种关于饮食的用户偏好。在饮食方面，四川人A和四川人群的饮食偏好程度 > 四川人A和湖南人群的饮食偏好程度 > 四川人A和湖北人群的饮食偏好程度。某人和某XX在某方面的偏好程度，也可以描述为用户相似度。请四川人吃饭点辣的食物，这就是基于用户的协同过滤算法的生活场景之一。

<img src="https://s2.ax1x.com/2019/07/24/eA6a60.png" alt="" border="0" />

**如何理解物品相似度？（基于物品的推荐）**

​		理论上，两个物品在某方面的属性或表现相似，就可以说两个物品在某方面是相似的。换句话来说，判断两个物品是否相似，必须找到一个评判的依据。这个依据是随意的，可以从物品内在的性质、外在的表现或者社会化的属性。比如，小明喜欢A、B和C，小丽喜欢A、C和D，小张喜欢B、E和F。观察三人拥有的物品，可以知道拥有A的也拥有C，可知AC的关联程度很高，即AC相似度很高。如果此时我已经拥有A，请问给我推荐什么商品最合适，显然应该把C推荐给我。这种人们拥有商品的关联程度是一种社会化的属性，是由人们的行为而产生的社会化结果。

<img src="https://s2.ax1x.com/2019/07/24/eA6Ulq.gif" alt="" border="0" />

## 2.协同过滤的基础

### 2.1  相似的计算

**夹角余弦**

夹角也叫余弦相似度，是用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小的度量。如果两个向量的方向一致，即夹角接近零，那么这两个向量就越相近。要确定两个向量方向是否一致，要用到余弦定理计算向量的夹角。

**皮尔逊相似度**

余弦相似度只与向量方向有关，但它会受到向量的平移影响，在夹角余弦公式中如果将 x 平移到 x+1, 余弦值就会改变。怎样才能实现平移不变性？这就要用到皮尔逊相关系数（Pearson correlation），有时候也直接叫相关系数.

**杰卡德相似度**

杰卡德相似系数与杰卡德距离的应用，可将杰卡德相似系数用在衡量样本的相似度上。 　　

样本A与样本B是两个n维向量，而且所有维度的取值都是0或1。例如：A(0111)和B(1011)。我们将样本看成是一个集合，1表示集合包含该元素，0表示集合不包含该元素。

## 3.基于用户的相似度

​		俗话说“物以类聚、人以群分”，拿看电影这个例子来说，如果你喜欢《蝙蝠侠》、《碟中谍》、《星际穿越》、《源代码》等电影，另外有个人也都喜欢这些电影，而且他还喜欢《钢铁侠》，则很有可能你也喜欢《钢铁侠》这部电影。

​		所以说，当一个用户 A 需要个性化推荐时，可以先找到和他兴趣相似的用户群体 G，然后把 G 喜欢的、并且 A 没有听说过的物品推荐给 A，这就是基于用户的系统过滤算法。

#### 3.1实现步骤

#### 3.1.1计算用户之间的相似度

1. 建立物品-用户倒排表

2. 建立用户相似度矩阵

3. 计算用户相似度

#### 3.1.2针对目标用户u，找到其最相似的K个用户，产生N个推荐

K表示与用户u兴趣相似的用户个数，N表示为用户u推荐的物品数

首先，对用户u，在用户相似度中找到与其相似度最高的K个用户，利用如下的公式计算用户u对物品i的感兴趣程度p(u, i)

然后根据感兴趣程度由高到低确定N个推荐给用户u的物品。

## 4.基于物品的相似度

基于物品的协同过滤算法(ItemCF)给用户推荐那些和他们之前喜欢的物品相似的物品。比如：该算法会因为你购买过《数据挖掘导论》而给你推荐《机器学习》。不过ItemCF算法不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大相似度的原因是因为喜欢物品A的用户大都也喜欢物品B。

###  4.1实现步骤

####  4.1.1计算物品之间的相似度

1. 遍历训练数据，统计喜欢每个物品的用户数
2. 建立物品相似度矩阵
3. 得到矩阵后，利用公式计算物品之间的相似度

#### 4.1.2根据物品的相似度和用户的历史行为给用户推荐

1. K表示找到相似的物品数。N表示为用户推荐的物品数 。

2. 利用公式计算用户u对物品 j 的感兴趣程度p(u, j)
3. 然后根据感兴趣程度由高到低确定N个推荐给用户u的物品。

## 5. 基于模型的协同过滤

　　　　基于模型的协同过滤作为目前最主流的协同过滤类型，其相关算法可以写一本书了，当然我们这里主要是对其思想做有一个归类概括。我们的问题是这样的m个物品，m个用户的数据，只有部分用户和部分数据之间是有评分数据的，其它部分评分是空白，此时我们要用已有的部分稀疏数据来预测那些空白的物品和数据之间的评分关系，找到最高评分的物品推荐给用户。

　　　　对于这个问题，用机器学习的思想来建模解决，主流的方法可以分为：用关联算法，聚类算法，分类算法，回归算法，矩阵分解，神经网络,图模型以及隐语义模型来解决。

## 6.评价指标

将用户行为数据按照均匀分布随机划分为M份(如取M=8)，挑选一份作为测试集，将剩下的M-1份作为训练集。为防止评测指标不是过拟合的结果，共进行M次实验，每次都使用不同的测试集。然后将M次实验测出的评测指标的平均值作为最终的评测指标。

### 6.1 召回率

​         对用户u推荐N个物品(记为R(u))，令用户u在测试集上喜欢的物品集合为T(u)

​         召回率描述有多少比例的用户-物品评分记录包含在最终的推荐列表中。

<img src="https://s2.ax1x.com/2019/08/15/mEEQ00.png" alt="" border="0" />

### 6.2 准确率

​         准确率描述最终的推荐列表中有多少比例是发生过的用户-物品评分记录

<img src="https://s2.ax1x.com/2019/08/15/mEE3kT.png" alt="" border="0" />

### 6.3 覆盖率

​         覆盖率反映了推荐算法发掘长尾的能力，覆盖率越高，说明推荐算法越能够将长尾中的物品推荐给用户。

​         分子部分表示实验中所有被推荐给用户的物品数目(集合去重)，分母表示数据集中所有物品的数目

<img src="https://s2.ax1x.com/2019/08/15/mEEYp4.png" alt="" border="0" />

